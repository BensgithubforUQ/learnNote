#include <iostream>
#include <string>
using namespace std;
//成员变量和成员函数是分开存储的
//只有非静态的成员变量属于类的对象上。
class blank {

};
//静态成员变量：
/*所有对象都共享一份数据，一旦改变，后续的就是改变后的那个量
* 在编译阶段分配内存//全局区
* 类内声明，类外初始化
*/
class Person {
public:
	int m_z;
	static  int m_A;//静态变量需要在类内声明
	//静态成员函数
	/*所有对象共享一个静态成员函数
	*静态函数只能访问静态成员变量
	*/
	static void func() {
		m_A = 0; // 静态函数只能访问静态成员变量
		//m_C = 100; //非静态成员引用必须与特定对象对应
		//因为静态成员函数是公用的，因此从这个函数体无法区分这个m_C是哪个特定的对象
		cout << "静态成员函数func的调用" << endl;
	}

	void func0() {
		cout << this->m_C << endl;
	}
	//但是这里就发现一个问题,链式编程情况下，除了第一个的返回对象的值被切实的输入到p_0里面
	//因为这里func1返回的是对象的值，而不是对象的地址，只是复制了一个副本。
	//如果把函数改成返回地址，那就每次都会加上去。
	/*Person func1(int m_C) {*/
	Person  &func1(int m_C) {
		this->m_C += m_C;
		return *this;
	}

	Person(int a, int c) :m_z(a), m_C(c) {

	}

	Person() {

	}

	void func4() {
		cout << "空指针调用成员函数测试用函数打印" << endl;
	}

	//和静态成员变量一样，静态成员函数有两种调用方法，一种是通过对象，一种是通过类名。
private:
	/*静态变量*/
	static  int m_B;
	int m_C;
};

int Person::m_A = 100;//静态变量需要在类外初始化
int Person::m_B = 200;
void test0() {
	Person p_0,p_1;
	cout << "m_A的值： " << p_0.m_A << endl;
	p_1.m_A = 200;
	cout << "改过p_1.m_A之后，p_0.m_A的值： " << p_0.m_A << endl;//所有对象公用这个静态变量的值
	cout << "地址：" << &(p_0.m_A) << " " << &(p_1.m_A) << endl;//可以发现实际上就是同一地址存储的值
	//这意味着实际上是在类内定义的一个全局区的静态变量，理所应当的是唯一的公用的。
	//一旦修改，则所有对象指向的这个静态变量的值都会被修改
}
//因此有两种方式访问静态变量，第一种是通过对象访问，第二种是通过类名访问。
int main() {
	test0();
	Person p_0(1,1);
	cout<<Person::m_A<<" " <<p_0.m_A<< endl;//第二种是通过类名访问静态变量。
	//但是静态变量也有访问权限的，private权限下的就不能再类外访问。
	//p_0.m_B;//因此是不合法的

	//两种访问静态成员函数的方法。
	p_0.func();
	Person::func();
	//同理，静态成员函数也有访问权限的，private权限下的就不能再类外访问，不再赘述。

	cout << endl;
	blank b;
	//成员函数和成员变量的存储
	/*
	*c++编译器会给空对象分配1个字节的内存空间，是为了区分空对象占内存的位置
	*每个空对象也有一个独一无二的内存地址
	*/
	cout << "size of empty class:" << sizeof(b) << endl;
	//person里面一共有两个非静态的int变量，每个int是4个字节，因此该类占8个字节
	//而因为成员变量和成员函数是分开存储的，所以sizeof并不能取到类的成员函数的大小
	cout << "size of person class:" << sizeof(p_0) << endl;

	//this指针。
	/*根据上述理由，因为静态的成员变量和静态的成员函数都是独一份的
	而非静态的成员函数实际上也只有一份函数实例，也就是说所有对象都共用这一份*/
	//那么成员函数如何确定是哪个对象在调用呢？

	//c++通过提供一种特殊的指针：this指针来解决上述问题（this指针指向被调用的成员函数所属的对象）
	//this 不需要定义，它隐含在所有非静态成员函数里。

	//this主要作用：
	//1.当形参和成员变量同名的时候，用this来区分，this+点操作指向的是对象的成员变量
	//2.在类的非静态成员函数中，如果需要返回对象本身，可以return *this。
	
	p_0.func1(11); //func1函数的形参传入（int）11，用m_C给this.m_C赋值，然后返回对象本身;
	//然后我们再新建一个对象
	p_0.func0();
	Person p_1;
	p_1 = p_0.func1(12).func1(13).func1(14);//这次没写拷贝构造函数，直接用默认的拷贝构造函数实现初始化
	p_0.func0();//但是这里就发现一个问题,链式编程情况下，除了第一个的返回对象的值被切实的输入到p_0里面
	//因为这里func1返回的是对象的值，而不是对象的地址，只是复制了一个副本。
	//如果把函数改成返回地址，那就每次都会加上去。
	p_1.func0();//然后调用p_1的func0，尝试获得p_1中this.m_c的打印


	//空指针
	//空指针调用成员函数,可以访问没有用到成员属性的函数，但是因为是空指针，对象连实体都没有
	//因此如果调用到成员变量，就会产生this―>?这种非法操作。
	Person* p_2 = NULL;
	p_2->func4();
	cout << "size of p_2:" << sizeof(p_2) << endl;
	return 0;
}	