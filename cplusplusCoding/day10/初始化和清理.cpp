#include "myHead.h"
#include "Fruit.h"

/*每个对象都需要初始化和在销毁对象之前的清理数据的设置
*对象的初始化和清理是强制进行的。
* 一个对象如果没有初始化，那使用这个对象的结果就是未知的
* 如果在使用完变量和对象之后没有清理，那就会有安全问题。
* 因此在c++中会强制用构造函数和析构函数来初始化和清理对象。
* 如果没有主动变现构造和析构函数，那么编译器会提供“空实现”的构造和析构函数。
* 构造函数：主要作用于创建对象时作为对象的成员属性赋值，构造函数由编译器自动调用，无需手动调用
* 析构函数：主要作用于对象销毁前的清理工作，系统自动调用，
* 构造函数语法：
* 类名（）{}
* 1.构造函数不返回值，也不void
* 2.函数名和类名相同
* 3.构造函数可以有参数，因此也可以重载
* 4.程序在调用对象时会自动调用构造函数，无需手动调用，并且只会调用一次

*/
/*构造函数的分类：按照参数分类，可以分为有参构造和无参构造
* 按照类型可以分为普通构造和拷贝构造
*/
//普通构造
Fruit::Fruit() {//无参构造函数
	cout << "用无参构造函数初始化一个fruit类对象" << endl;
}

Fruit::Fruit(string c) {//有参构造函数
	color = c;
	cout << "用有参构造函数初始化一个fruit类对象" << endl;
}
//拷贝构造
Fruit::Fruit(const Fruit& f) {//拷贝构造
	color = f.color;//用另外一个对象的属性来初始化
	cout << "用拷贝构造函数初始化一个fruit类对象" << endl;
}
/* 析构函数语法：
* ~类名（）{}
* 1.构造函数不返回值，也不void
* 2.函数名和类名相同，在前面加个~
* 3.析构函数不可以有参数，因此也不可以重载
* 4.程序销毁对象前会自动调用析构函数，无需手动调用，并且只会调用一次
*/
Fruit::~Fruit() {//析构函数
	cout << "清理一个fruit类对象" << endl;
}

void Fruit::getColor() {
	cout << "颜色是：" << color << endl;
}