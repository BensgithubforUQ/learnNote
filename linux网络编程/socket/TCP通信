
物理层，数据链路层，网络层 ，传输层，会话层，表示层，应用层
   数据链路层，网络层，传输层，应用层
   tcp和udp -- 都是传输层协议
udp：用户数据协议，面向无链接，可以单播，多播，广播，面向数据报，不可靠，但是效率比较高.//实时性比较高的，视频会议
首部开销8个字节

tcp：传输控制协议，面向连接的，是可靠的，基于字节流的，只支持单播，点对点传输。//可靠性比较高的，文件传输
首部开销最少20个字节。

tcp通信流程
服务器端（被动接受连接的角色）
1.创建一个用于监听的套接字socket
    -监听客户端的连接
    -套接字就是一个文件描述符
2.将这监听的文件描述符和本地IP端口绑定（ip和端口就是服务器的地址信息）
    -客户端连接服务器的时候，使用的就是这个ip和端口
3.设置监听，监听的fd开始工作（fd字符描述符）
4.阻塞等待，当有客户端发起连接，解除阻塞，接受客户端的连接，会得到一个新的文件描述符（socket）和客户端建立通信
5.通信
    -接收数据
    -发送数据
6.通信结束，断卡连接

客户端（主动连接的角色）
1.创建一个用于通信的套接字
2.连接服务器，需要指定连接的服务器的端口和IP
3.连接成功，客户端和服务器进行通信
4.通信+
5.通信结束，断卡连接

客户端与服务器之间数据的发送和返回的过程当中需要创建一个叫TCP connection的东西；

由于TCP不存在连接的概念，只存在请求和响应，请求和响应都是数据包，它们之间都是经过由TCP创建的一个从客户端发起，
服务器接收的类似连接的通道，这个连接可以一直保持，http请求是在这个连接的基础上发送的；

在一个TCP连接上是可以发送多个http请求的，不同的版本这个模式不一样。

在HTTP/1.0中这个TCP连接是在http请求创建的时候同步创建的，http请求发送到服务器端，
服务器端响应了之后，这个TCP连接就关闭了；

HTTP/1.1中可以以某种方式声明这个连接一直保持，一个请求传输完之后，另一个请求可以接着传输。、
这样的好处是：在创建一个TCP连接的过程中需要“三次握手”的消耗，“三次握手”代表有三次网络传输。

如果TCP连接保持，第二个请求发送就没有这“三次握手”的消耗。HTTP/2中同一个TCP连接里还可以并发地传输http请求。

TCP报文格式
16 源端口 | 16 目的端口
序号 sequence number (seq) 32位，用来标识从TCP源端向目的端发送的字节流，发起方发送数据时对此进行标记
确认号 acknowledgement number (ack) 32位，只有ACK标志位为1的时候，确认序号字段才有效，ack = seq + 1 
16 偏移 保留 flags（标志位） | 16 窗口 
检验合 | 紧急指针
可变部分

标志位（Flags）：
URG： 紧急指针，有效
ACK： 确认序号有效
PSH： 接收方应该尽快将这个报文交给应用层
RST： 重置连接 
SYN： 发起一个新连接
FIN： 释放一共连接

三次握手:需要互相确认对方收到了自己的信息。

客户端 --- SYN = 1(发起一个新连接),c_seq = x ---> 服务器端(LISTEN)
(SYN-SENT)
客户端 <--- SYN = 1(应答连接), s_ack = x( c_seq ) + 1， s_seq = y --- 服务器端 (SYN-RCVD)
(ESTABLISHED)                                                        
客户端 --- SYN = 1 (发起连接), c_ack = y ( s_seq ) + 1, c_seq = x(原c_seq) + 1 ---> 服务器端(ESTABLISHED)  
 
“第三次握手”是客户端向服务器端发送数据，这个数据就是要告诉服务器，客户端有没有收到服务器“第二次握手”时传过去的数据。
若发送的这个数据是“收到了”的信息，接收后服务器就正常建立TCP连接，否则建立TCP连接失败，服务器关闭连接端口。
由此减少服务器开销和接收到失效请求发生的错误。

滑动窗口：win
mss: maximum segment size, 一条数据的最大数据量
1.三次握手：客户端向服务器发起连接，客户端的win是4096，一次发送的最大数据量是1460
2.三次握手：服务器接受连接情况，告诉客户端服务器的窗口大小是6144，一次发送的最大数据量是1024
3.第三次握手

ESTABLISHED：
4.客户端连续给服务器发送了6*1024的数据，每次发送1024
5.服务器告诉客户端，发送的6k数据及时收到，存储在缓冲区中，缓冲区已经处理了2k，窗口大小是2k
6.服务器告诉客户端，发送的6k数据及时收到，存储在缓冲区中，缓冲区已经处理了4k，窗口大小是4k
7.客户端继续给服务器发送数据

8.四次挥手: 客户端主动请求断开连接(FIN), 同时携带数据1k(可以携带)。
9.四次挥手：服务器确认收到数据，和，确认收到FIN，,同意断开连接的请求，继续用滑动窗口处理完剩下的数据。
10.四次挥手：服务器回复ACK,a.确认收到的数据量，b.回报win大小，c.发送FIN。
11.四次挥手：客户端同意了服务器端的断开请求
12.销毁对方信息

四次挥手：
                            (ESTABLISHED)
(FIN-WAIT-1)终止等待
客户端：主动关闭 --- FIN = 1,seq = u ---> 服务器(接收到信息后，进入CLOSE-WAIT)
客户端：(接收到ACK确认序号有效后，进入FIN-WAIT-2) <---ACK = 1,seq = v,ack = u + 1(FIN)---服务器
            (第二次挥手和第三次挥手之间，还有服务器对客户端的数据传输)
客户端:(接收到FIN) <--- FIN = 1,ACK =1 ,seq = w,ack = u + 1---服务器:已经准备好释放连接了(LAST-ACK最后确认)
客户端(发送最终确认后，进入TIME-WAIT状态) ---ACK = 1, seq = u + 1, ack = u + 1--->服务器 (收到后CLOSED) 
-客户端等待2MSL-
(CLOSED) 

所谓的四次挥手即TCP连接的释放(解除)。连接的释放必须是一方主动释放，另一方被动释放。
前"两次挥手"既让服务器端知道了客户端想要释放连接，也让客户端知道了服务器端了解了自己想要释放连接的请求。
于是，可以确认关闭客户端到服务器端方向上的连接了.

为什么要客户端要等待2MSL:
服务器端收到从客户端发出的TCP报文之后结束LAST-ACK阶段，进入CLOSED阶段。
由此正式确认关闭服务器端到客户端方向上的连接。

在第三次挥手(服务器端发送FIN,ACK之后，如果一个MSL内没有收到客户端回复，就会再发一次)
在第四次挥手之后，如果2MSL内没有接收到服务器端的(FIN,ACK重发)，就默认服务器端接已经收到了最终确认(ACK)

客户端等待完2MSL之后，结束TIME-WAIT阶段，进入CLOSED阶段，由此完成“四次挥手”。
确保由于网络堵塞等原因迟到且客户端重发的消息在本次连接中作废掉，而不会进入下一次连接中

TCP状态转换



